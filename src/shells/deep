#!/usr/bin/perl -w

use strict 'vars';

# Get these modules from http://www.cpan.org if you don't have them already
use Getopt::Long;
use File::Glob ':glob';

# 'deep' utility
my $version = "v2.1 2002-04-04";
# Copyright 2002 by Neil Gunton
# http://www.neilgunton.com

# Script for recursing over subdirectories and performing various operations on files
# which match a given pattern. Current commands are:
#  chmod     - recursively chmod files matching a given pattern
#  clean     - recursively delete files ending in '~' (usually left behind by editors)
#  delete    - recursively delete files matching a given pattern
#  find      - recursively find a string in files matching a given pattern
#  rename    - recursively rename files with a given extension to a different extension
#  replace   - recursively replace a string with another string in files matching a given pattern

# Just type the script name without any parameters (i.e. 'deep') to see syntax guide.

# The file pattern can be a list of patterns, separated by spaces, e.g. "*.c *.cpp".
# If you do this, then you need to be sure to put quotes around this list on the command line.
# You should put quotes around any pattern on the command line which contains wildcards,
# otherwise the shell will expand this BEFORE passing it to Perl, which is not what we want,
# since the shell is only looking at the current directory, and we need the untouched wildcard for
# subdirectories.

# Note: This is free software. Use it at your own risk.

# ------------------------------------------------------------------------------------------------------
# Main recursive directory traversal subroutine
# ------------------------------------------------------------------------------------------------------

sub traverse
{
    my ($dir,            # The current directory which is to be processed
	$pattern,        # A pattern identifying files to be processed, e.g. "*.html *.epl"
	$subref,         # Subroutine reference, a callback function to process each file
	@sub_parms       # Parameter list to pass to the callback function
	) = @_;

    local *DIR;
    opendir (DIR, $dir) or die "Could not open directory: $dir: $!";

    # First, process files in this directory
    # Pattern consists of a potential list of patterns, separated by spaces.
    # First we make a list of patterns, and then glob each of these
    foreach my $glob (split (/\s/, $pattern))
    {
	# Iterate through the resulting list of files
	foreach my $file (File::Glob::glob ("$dir/$glob"))
	{
	    if (!(-d $file) && (-e $file))
	    {
		$subref->($file, @sub_parms);
	    }
	}
    }

    # Now, recursively go down into subdirectories
    while (defined(my $file = readdir (DIR)))
    {
	# Only recurse on directories, which do not start with ".", and skip symbolic links
	if (-d "$dir/$file" &&
	    !(-l "$dir/$file") &&
	    ($file !~ /^\.{1,2}$/))
	{
	    traverse ("$dir/$file", $pattern, $subref, @sub_parms);
	}
    }
}

# ------------------------------------------------------------------------------------------------------
# Config file routine
# Looks for .deep.cfg in . (current directory), then ~/ (user's home dir)
# Reads in file pattern string from the file, if found
# ------------------------------------------------------------------------------------------------------

sub get_config
{
    my $path = (-e "./.deep.cfg") ? "./.deep.cfg" : "$ENV{HOME}/.deep.cfg";
    if (!(-e $path))
    {
	return undef;
    }
    else
    {
	open CONFIG, "< $path" or die "Could not open config file: $path: $!";
	my $pattern = <CONFIG>;
	close CONFIG;
	return $pattern;
    }
}

# ------------------------------------------------------------------------------------------------------
# The command subroutines
# There are two subroutines for each command: cmd_<command> and callback_<command>
# cmd_command is the main subroutine which checks syntax and calls the main traversal routine
# callback_command is the subroutine which traverse() calls for each file
# ------------------------------------------------------------------------------------------------------

# ------------------------------------------------------------------------------------------------------
# COMMAND: chmod
# ------------------------------------------------------------------------------------------------------

sub cmd_chmod
{
    my ($permissions, $pattern) = @_;

    if (!$permissions || !$pattern)
    {
	print qq{Syntax: deep chmod <numeric permissions> <file pattern>\n};
	print qq{e.g. deep chmod 755 "*.html"\n};
    }
    else
    {
	traverse ('.', $pattern, \&callback_chmod, ($permissions));
    }
}

# ------------------------------------------------------------------------------------------------------

sub callback_chmod
{
    my ($filename, $permissions) = @_;

    chmod (oct($permissions), $filename) or die "Could not chmod file: $filename: $!";
    print "chmod $permissions $filename\n";
}

# ------------------------------------------------------------------------------------------------------
# COMMAND: clean
# Deletes files ending in ~ (usually left behind by editors)
# ------------------------------------------------------------------------------------------------------

sub cmd_clean
{
    # Recursively delete all files ending in ~, including files beginning with '.'
    traverse ('.', '*~ .*~', \&callback_clean);
}

# ------------------------------------------------------------------------------------------------------

sub callback_clean
{
    my ($filename) = @_;

    unlink $filename or die "Could not delete file: $filename: $!";
    print "Deleted $filename\n";
}

# ------------------------------------------------------------------------------------------------------
# COMMAND: delete
# ------------------------------------------------------------------------------------------------------

sub cmd_delete
{
    my ($pattern) = @_;

    # Get the options
    my ($real);
    GetOptions ('real' => \$real);

    if (!$pattern)
    {
	print qq{Syntax: deep delete <file pattern> [--real]\n};
	print qq{  --real option forces deletion 'for real'. Omit for dummy run, you'll be told what would be deleted.\n};
	print qq{e.g. deep delete "*.ico" --real\n};
    }
    else
    {
	traverse ('.', $pattern, \&callback_delete, ($real));
    }
}

# ------------------------------------------------------------------------------------------------------

sub callback_delete
{
    my ($filename, $real) = @_;

    if (!$real)
    {
	print "Would delete $filename\n";
    }
    else
    {
	unlink $filename or die "Could not delete file: $filename: $!";
	print "Deleted $filename\n";
    }
}

# ------------------------------------------------------------------------------------------------------
# COMMAND: find
# ------------------------------------------------------------------------------------------------------

sub cmd_find
{
    my ($search_string, $pattern) = @_;

    # Get the options
    my ($case, $delete, $literal);
    $case = 1;
    $literal = 1;
    GetOptions ('case=i'    => \$case,
		'literal=i' => \$literal,
		'delete'    => \$delete);

    if (!$pattern || $pattern =~ /^\-/)
    {
	$pattern = get_config();
    }

    if (!$pattern || !$search_string)
    {
	print qq{Syntax: deep find <search string> [<file pattern>] [--case=1|0] [--delete]\n};
	print qq{  --case=1      case sensitive search (default)\n};
	print qq{  --case=0      case insensitive search\n};
	print qq{  --delete      delete files which contain a match\n};
	print qq{  --literal=1   backslash special pattern-match characters, i.e. treat string literally (default)\n};
	print qq{  --literal=0   do not backslash special pattern-match characters, i.e. allow regular expressions\n};
	print qq{This command checks the command line, then ./.deep.cfg, then ~/.deep.cfg for a single-line file pattern.};
	print qq{e.g. deep find 'hooty' '*.html *.epl' --case=0 --delete\n};
    }
    else
    {
	traverse ('.', $pattern, \&callback_find, ($search_string, $case, $literal, $delete));
    }
}

# ------------------------------------------------------------------------------------------------------

sub callback_find
{
    my ($filename, $search_string, $case, $literal, $delete, $subhashref) = @_;

    # Open up the input file
    open (INFILE, "< $filename") or die "Could not open file for reading: $filename: $!";
    
    # Keep note of whether we have found the string in this file yet
    my $found = 0;

    # Read in all the lines of the input file
    while (my $line = <INFILE>)
    {
	# Search for the string in the current line
	my $result = $case
	    ? $literal
	      ? ($line =~ /\Q$search_string\E/)
	      : ($line =~ /$search_string/)
	    : $literal
	      ? ($line =~ /\Q$search_string\E/i)
	      : ($line =~ /$search_string/i);

	# Print out the filename, if this is the first occurance
	if ($result && !$found)
	{
	    print "$filename\n";
	}
	
	# Take note of whether we found anything yet - so we can tell the first occurrence
	$found = $found ? $found : $result;

	# Print out the string if it was found
	if ($result)
	{
	    # Get rid of any leading tabs or spaces
	    $line =~ s/^\s*//;
	    print "\t$.\t$line";
	}
    }

    # If this is finddel or finddeli, then delete the file
    if ($found && $delete)
    {
	unlink $filename or die "Could not delete file: $filename: $!";
	print "Deleted $filename\n";
    }

    close (INFILE);
}

# ------------------------------------------------------------------------------------------------------
# COMMAND: rename
# ------------------------------------------------------------------------------------------------------

sub cmd_rename
{
    my ($old_ext, $new_ext) = @_;

    if (!$old_ext || !$new_ext)
    {
	print qq{Syntax: deep rename <file extension> <new extension>\n};
	print qq{e.g. deep rename JPEG jpg\n};
    }
    else
    {
	traverse ('.', "*$old_ext", \&callback_rename, ($old_ext, $new_ext));
    }
}

# ------------------------------------------------------------------------------------------------------

sub callback_rename
{
    my ($filename, $old_ext, $new_ext) = @_;

    if ($filename =~ /$old_ext$/)
    {
	my $new_filename = $filename;
	$new_filename =~ s/$old_ext$/$new_ext/;
	print "Renamed $filename => $new_filename\n";
	rename ($filename, $new_filename) or die "Could not rename file: $filename: $!";
    }
}

# ------------------------------------------------------------------------------------------------------
# COMMAND: replace, replacei
# ------------------------------------------------------------------------------------------------------

sub cmd_replace
{
    my ($from, $to, $pattern) = @_;

    # Get the options
    my ($case, $literal);
    $case = 1;
    $literal = 1;
    GetOptions ('case=i'  => \$case,
		'literal=i' => \$literal);

    if (!$pattern || $pattern =~ /^\-/)
    {
	$pattern = get_config();
    }

    if (!$pattern || !$from)
    {
	print qq{Syntax: deep replace <search string> <replace string> [<file pattern>] [--case=1|0] [--literal=1|0]\n};
	print qq{  --case=1      case sensitive search (default)\n};
	print qq{  --case=0      case insensitive search\n};
	print qq{  --literal=1   backslash special pattern-match characters, i.e. treat string literally (default)\n};
	print qq{  --literal=0   do not backslash special pattern-match characters, i.e. allow regular expressions\n};
	print qq{This command checks the command line, then ./.deep.cfg, then ~/.deep.cfg for a single-line file pattern.};
	print qq{e.g. deep replace "*.html" "hooty" "blowfish" --case=0\n};
    }
    else
    {
	# Set up the substitution subs array ref, indexed by [case][literal]
	# This is necessary to enable the correct working of variable interpolation with $1, $2, etc in replacement ($to)
	my $subarrayref = [[eval ('sub {$_ = shift; $$_ =~ ' . "s/$from/$to/gi}"),
			    eval ('sub {$_ = shift; $$_ =~ ' . "s/\Q$from\E/\Q$to\E/gi}")],
			   [eval ('sub {$_ = shift; $$_ =~ ' . "s/$from/$to/g}"),
			    eval ('sub {$_ = shift; $$_ =~ ' . "s/\Q$from\E/\Q$to\E/g}")]];
	traverse ('.', $pattern, \&callback_replace, ($case, $literal, $from, $to, $pattern, $subarrayref));
    }
}

# -----------------------------------------------------------------------------------------------------

sub callback_replace
{
    my ($filename, $case, $literal, $from, $to, $pattern, $subarrayref) = @_;

    # Open up the input and temporary output files
    open (INFILE, "< $filename") or die "Could not open file for reading: $filename: $!";
    open (OUTFILE, "> $filename.tmp") or die "Could not open temp file for writing: $filename.tmp: $!";
    
    # Keep note of whether we have modified the file
    my $changed = 0;

    # Read in all the lines of the input file
    while (my $line = <INFILE>)
    {
	# Do the replace operation on the current line
	my $result = $subarrayref->[$case][$literal]->(\$line);
	
	# Take note of whether the file has been changed
	$changed = $changed ? $changed : $result;

	# Output the (possibly) modified line to the temp file
	print OUTFILE $line;
    }
    close (INFILE);
    close (OUTFILE);

    if ($changed)
    {
	# Delete the old file, and rename the new one
	rename ("$filename.tmp", $filename) or die "Could not rename temp file: $filename.tmp: $!";
	print "Modified $filename\n";
    }
    else
    {
	# Remove the temp file
	unlink "$filename.tmp" or die "Could not remove temp file: $filename.tmp: $!";
    }
}

# -----------------------------------------------------------------------------------------------------

sub do_syntax
{
print <<ENDSYNTAX

deep utility $version
Copyright 2002 by Neil Gunton http://www.neilgunton.com

Syntax:
    deep chmod <numeric permissions> <file pattern>
    deep clean
    deep delete <file pattern> [--real]
    deep find <search string> [<file pattern>] [--case=1|0] [--literal=1|0] [--delete]
    deep rename <file extension> <new extension>
    deep replace <search string> <replace string> [<file pattern>] [--case=1|0] [--literal=1|0]

Type a command by itself for detailed syntax on that command, e.g. 'deep replace'.

File patterns can be a list of patterns, separated by spaces,
e.g. '*.c *.cpp'.  Always put single quotes around wildcard file
patterns, e.g. '*.html' rather than just *.html.  This is because some
shells automatically expand patterns before passing them to Perl.

The find and replace commands first check on the command line for a
file pattern, then (if not present) look for ./.deep.cfg and finally
~/.deep.cfg.  If present then this file must contain a single line
filename pattern.  This allows you to omit the filename pattern on the
command line for these commands.

ENDSYNTAX
}

# =====================================================================================================
# Main code
# =====================================================================================================

{
    # This is a hash which maps the command name to its subroutine
    my %commands = (
		    'chmod'    => \&cmd_chmod,
		    'clean'    => \&cmd_clean,
		    'delete'   => \&cmd_delete,
		    'find'     => \&cmd_find,
		    'rename'   => \&cmd_rename,
		    'replace'  => \&cmd_replace,
		    );

    # There should always be a command
    my $command = shift;

    # Do the command, or print an error message
    if (!$command || !$commands{$command})
    {
	do_syntax();
    }
    else
    {
	$commands{$command}->(@ARGV);
    }
}

1;

# ------------------------------------------------------------------------------------------------------
# End of file
# ------------------------------------------------------------------------------------------------------
